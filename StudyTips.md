[TOC](文章目录)

<a name="Menutop" >顶部</a>

# [目录](#目录)

- [简介](#简介)
- [GitTips](#GitTips)
  - [git gc](#git_gc)
  - [git push](#git_push)
- [LinuxTips](#LinuxTips)
- [STM32Tips](#STM32Tips)
  - [内存分配](#内存分配)

- [ShellTips](#ShellTips)
  - [udhcpc](#udhcpc)
- [VimTips](#VimTips)
  - [编辑](#编辑)
  - [移动光标](#移动光标)
  - [进入和退出](#进入和退出)
  - [删除](#删除)
  - [撤销](#撤销)
  - [定位](#定位)
  - [外部命令](#外部命令)
- [ElectronicsTips](#ElectronicsTips)
  - [晶振](#晶振)
  - [CPU](#CPU)
  - [MPU](#MPU)
  - [MCU](#MCU)
  - [SoC](#SoC)


# <a name="GitTips" >**GitTips**</a>

​	

~~~c
git init
git add 
git commit
git remote add origin http://name:password@gitee.com/zhaochengjie/gitname.git
~~~





## <a name="git gc" >**git_gc**</a>

- ~~~c 
  git gc --prune=now 

​				解决本地缓存过大的问题，清理本地缓存

## <a name="git push" >**git push**</a>

- ~~~c
  git push --force origin master
  ~~~

  强制推送覆盖到远程仓库

  





# <a name="LinuxTips" >**LinuxTips**</a>



# <a name="STM32Tips" >**STM32Tips**</a>



## <a name="内存分配" >**内存分配**</a>

- const修饰的常量，不管在局部还是全局	存放在flash 中，不占用RAM,所以为了节省RAM,把常量的字符串，数据等声明为const是推荐的一种做法
- static修饰的变量，不管是在局部还是在全局	存放于RAM 的.data段，就是已初始化变量区。static不显示初始化默认为初始化为0
- 初始化的全局变量	存放在RAM 的.data段，就是已初始化变量区。static不显示初始化默认为初始化为0
- 未初始化的全局变量	放在RAM的.bss段，也就是没有显示的进行初始化
- HEAP 即堆区	存放于RAM的HEAP段，堆区内存需要程序员用malloc和free进行动态分配和释放，注意不要丢失、改写了申请内存后得到的指针，以免释放不了，造成内存泄漏
- STACK 即栈区	存放于RAM 的STACK段，这部分是程序运行时函数局部变量使用的，使用完自动释放





# <a name="ShellTips" >**ShellTips**</a>

​	

## <a name="udhcpc" >**udhcpc**</a>

- ~~~c 
  udhcpc -i usb1
  ~~~

​			动态获取ip配置

udhcpd就是终端设备作为DHCP服务器

udhcpc就是终端设备作为DHCP客户端



## <a name="dir" >**dir**</a>

- ls(list)：会显示不同类型的文件的颜色

  dir(directory)：不显示不同文件类型的文件颜色，所有文件都是一种颜色

  但两种指令的作用都是显示当前目录下的文件。

## <a name="yes" >**yes**</a>



- 单个yes输出y
- yes + 字符串。 连续输出字符串。

# <a name="VimTips" >**VimTips**</a>



~~~mermaid
graph LR
    
A["一般模式</br>游标的移动,搜寻与取代，</br>删除资源，删除整列，</br>复制整列，粘贴整列"] --"i,o,a(插入)R(取代)"-->B["编辑模式</br>以插入或取代来编辑档案内容"]
B --"ESC"-->A
 C["指令列模式</br>读取/存储档案，其他额外功能"] --"ESC"-->A
  A --":，/，?"-->C


~~~



## <a name="编辑" >**编辑**</a>

- 编辑模式：在一般模式中可以迚行删除、复制、贴上等等癿劢作，但是却无法编辑文件内容癿！要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母乊后才会迚入编辑模式。注意了！通常在Linux中，按下这些按键时，在画面癿左下方会出现『INSERT戒REPLACE』癿字样，此时才可以迚行编辑。而如果要回到一般模式时，则必须要按下『Esc』这个按键即可退出编辑模式。
- 在vi 里面，[tab] 这个按钮所得到癿结果不空格符所得到癿结果是丌一样癿，特别强调一下！
- 需要注意癿是，如果你癿档案权限丌对，例如为\-r\--r-\-r\--时，那么可能会无法写入，此时可以使用『强制写入』癿方式吗？可以！使用『:wq!』多加一个惊叹号即可！丌过，需要特别注意呦！那个是在『你癿权限可以改变』癿情况下才能成立癿！

## <a name="移动光标" >**移动光标**</a>

- h 的键位于左边或左箭头键(←)，每次按下就会向左移动;

  l 的键位于右边或或向右箭头键(→)，每次按下就会向右移动;

  j 键看起来很象一支尖端方向朝下的箭头向下箭头键(↓);

  k键每次按下就会向上移动或向上箭头键(↑).

- 如果想要进行多次移动的话，例如向下移动30 行，可以使用"30j" 或"30

  ↓" 的组合按键，亦即加上想要进行的次数(数字)后，按下动作即可！

- ​	H:光标移动到这个屏幕最上方那一行的第一个字符

-  M；光标移动到这个屏幕的中央那一行的第一个字符

-  L：光标移动到这个屏幕的最下方那一行的第一个字符

-  G:移动到这个档案的最后一行

-  nG ：n为数字。移动到这个档案的第n行。例如20G则会移动到这个档案的第20行（可配合:set nu）

- gg : 移动到这个档案的第一行，相当于1G啊！

- n <Enter> : n为数字。光标向下移动n行

- /word 向光标之下寻找一个名称为word的字符串。例如要在档案内搜寻HandsomeZCJ这个字符串，就输入 /HandsomeZCJ 即可

-  ?word 向光标之上寻找一个字符串名称为word的字符串 

-  n ：这个n是英文按键。代表【重复前一个搜寻的动作】。距离来说，如果刚刚我们执行 /HandsomeZCJ   去向下搜寻HandsomeZCJ   这个字符串，则按下n后，会向下继续搜寻下一个名称为HandsomeZCJ   的字符串。如果是执行 ?HandsomeZCJ 的话，那么按下n则会向上继续搜寻名称为HandsomeZCJ   的字符串。   

- N ：这个N是英文按键。与n刚好相反，为【反向】进行前一个搜寻动作。例如/HandsomeZCJ   后，按下N则表示【向上】搜寻HandsomeZCJ   

-  :n1,n2s/word1/word2/g   ： n1 与 n2 为数字。在第 n1 与 n2 行之间寻找word1 这个字符串，并将该字符串取代为word2 ！丼例来说，在100 到

  200 行乊间搜寻vbird 并叏代为VBIRD 则：『:100,200s/vbird/VBIRD/g

  』。(常用)

- :1,$s/word1/word2/g    ：从第一行到最后一行寻找word1字符串，并将该字符串取代为word2
- :1,$s/word1/word2/gc    ： 从第一行到最后一行寻找word1字符串，并将该字符串取代为word2，且在取代前显示提示字符给用户确认（confirm）是否需要取代







~~~mermaid
graph LR
A("Ctrl+f") ----> B("屏幕向下移动一页，相当于【page down按键】")
C("Ctrl+b") ----> D("屏幕向上移动一页，相当于【page up按键】")
E("Ctrl+d") ----> F("屏幕向下移动半页")
G("Ctrl+u") ----> H("屏幕向上移动半页")
I("+") ---->J("光标移动到非空格符的下一列")
K("-") ---->L("光标移动到非空格符的上一列")

~~~

~~~mermaid
graph LR
M("n< space >")---->N("那个n表示『数字』，</br>例如20。按下数字后再按空格键，</br>光标会向右移动这一行的n个字符。</br>例如20<space>则光标</br>会向后面移动20 个字符距离。")
~~~

~~~mermaid
graph LR
A["0或功能键【home】"]---->B("数字0，移动到这一行的最前面字符处")
C(("$或者功能键【End】"))---->D("移动到这一行的最后面字符处")
~~~



## <a name="进入和退出" >**进入和退出**</a>

- 首先确保自己在正常模式（ 按<ESC>键）

然后按键盘上按下”shift+：”，输入“q！”，回车

这种方式的退出编辑器会丢弃您进入编辑器以来所做的改动

输入“wq”则会保存所做的改动。



## <a name="删除" >**删除**</a>

- 输入dd删除该行。
- 输入ndd删除n行，n代表删除以下多少行。
- 在一行字当中，x 为向后删除一个字符（相当于【del】按键）， X 为向前删除一个字符（相当于【backspace】亦既是退格键）
- nx ：n为数字，连续向后删除n个字符。举例来说，我要连续删除10个字符 【10x】
- d1G  ：删除光标所在到第一行的所有数据
- dG   ：删除光标所在到最后一行的所有数据
-  d$  ：删除游标所在处，到该行的最后一个字符
- d0   ： 那个是数字的0，



## <a name="撤销" >**撤销**</a>

- 输入u撤销最后一次执行的命令。
- 输入Ctrl+R可以重做被撤销的命令。

## <a name="定位" >**定位**</a>

- 输入大写 G 可以使得当前光标直接跳转到文件最后一行。
-  输入 gg 可以使得当前光标直接跳转到文件第一行。

- 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底 部，这跟 : 命令是一样的。接着输入 errroor <回车>。那个errroor就是您要查找的字符串。要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字 符串，请输入大写 N 即可。如果您想逆向查找字符串，请使用 ? 代替 / 进行。

## <a name="外部命令" >**外部命令**</a>

- 输入 :! 然后紧接着输入一个外部命令可以执行该外部命令按下我们所熟悉的 : 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。我们以 ls 命令为例。输入 !ls <回车> 。该命令就会列举出您当前目录的 内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起 作用，您可以试试 :!dir 看看。







# <a name="ElectronicsTips" >**ElectronicsTips**</a>



## <a name="晶振" >**晶振**</a>



- 电子线路中的晶体振荡器也分为无源晶振和有源晶振两种类型。无源晶振与有源晶振的英文名称不同，无源晶振为crystal（晶体），而有源晶振则叫做oscillator（振荡器）。无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来，所以“无源晶振”这个说法并不准确；有源晶振有4只引脚，是一个完整的振荡器，其中除了石英晶体外，还有晶体管和阻容元件，因此体积较大。



## <a name="CPU" >**CPU**</a>

- CPU(Central Processing Unit)，是一台计算机的运算核心和控制核心。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。主要功能是解释计算机指令以及处理计算机软件中的数据。计算机的可编程性主要是指对中央处理器的编程。1970年代以前，中央处理器由多个独立单元构成，后来发展出由集成电路制造的中央处理器，这些高度收缩的组件就是所谓的微处理器，其中分出的中央处理器最为复杂的电路可以做成单一微小功能强大的单元，也就是所谓的核心。差不多所有的CPU的运作原理可分为四个阶段：提取(Fetch)、解码(Decode)、执行(Execute)和写回(Writeback)。 CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。



## <a name="MPU" >**MPU**</a>



- MPU (Micro Processor Unit)，叫微处理器，是可编程特殊集成电路。MPU只是一个处理器，需要搭配内存等非常多的其他外设才可以构成一个系统。MCU内部有处理器、内存、Flash及其他模块，仅仅需要搭配少量外设就可以构成一个系统。在上世纪80年代非常流行，那时的微型计算机、游戏机都是使用MPU。比如Motorola公司的68000芯片就是一款主流的微处理器(MPU)。下图是一款Alpha Micro AM-1000系列的微型计算机电路板，电路板右侧中间最大的芯片就是MPU 68000。后来MPU逐渐式微，可以认为MPU发现到现在只剩下了intel、AMD公司x86系列CPU。这类CPU也越来越复杂，称之为“微处理器”似乎不恰当了。在个人电脑领域，可以看到类似下图的主板。主板上插上CPU、内存条、声卡等等就构成了一台计算机。整个主板体积庞大、制造复杂。



## SoC<a name="MCU" >**MCU**</a>



- MCU(Micro Control Unit)，叫微控制器，是指随着大规模集成电路的出现及其发展，把中央处理器、存储器、定时/计数器（timer/counter）、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机，形成芯片级的芯片。与应用在个人电脑中的通用型微处理器相比，它更强调自供应（不用外接硬件）和节约成本。它的最大优点是体积小，可放在仪表内部，但存储量小，输入输出接口简单，功能较低。MCU的发展经历过8位8051单片机、16位AVR单片机、32位STM单片机。MCU内部集成了处理器和各类模块，比如USB控制器、UART控制器、内存、Flash等等。只需要外接少量的器件，就可以搭建一个电子系统。



## <a name="SoC" >**SoC**</a>



- 单片系统或片上系统（英语：System on a Chip，缩写：SoC）是一个将电脑或其他电子系统集成到单一芯片的集成电路。单片系统可以处理数字信号、模拟信号、混合信号甚至更高频率的信号。单片系统常常应用在嵌入式系统中。单片系统的集成规模很大，一般达到几百万门到几千万门。SoC可以基于 MCU或 MPU，并将提供执行某些类型的应用程序所需的一切。例如，对于图像处理，SoC可能具有 MPU、数字信号处理器 (DSP)和/或图形处理单元 (GPU)的组合，用于执行快速算法计算，以及用于驱动显示器和 HDMI或其他音频/视频输入/输出技术。SoC可在单个微型 IC上实现整个芯片系统。
