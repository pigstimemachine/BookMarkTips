[TOC](文章目录)

<a name="Menutop" >顶部</a>

- 做技术的，永远不要和客户硬刚。

# [目录](#目录)

- [简介](#简介)
- [GitTips](#GitTips)
  - [git gc](#git_gc)
  - [git push](#git_push)
- [LinuxTips](#LinuxTips)
- [STM32Tips](#STM32Tips)
  - [内存分配](#内存分配)

- [ShellTips](#ShellTips)
  - [udhcpc](#udhcpc)
  - [history](#history)
  - [alias](#alias)
  - [通配符](#通配符)
  - [type](#type)
  - [read](#read)
  - [declare/typeset](#declare/typeset)
  - [ulimit](#ulimit)
  - [dd](#dd)
- [VimTips](#VimTips)
  - [编辑](#编辑)
  - [移动光标](#移动光标)
  - [进入和退出](#进入和退出)
  - [删除](#删除)
  - [撤销](#撤销)
  - [定位](#定位)
  - [外部命令](#外部命令)
  - [复制](#复制)
  - [粘贴](#粘贴)
  - [指令列](#指令列)
- [ElectronicsTips](#ElectronicsTips)
  - [晶振](#晶振)
  - [CPU](#CPU)
  - [MPU](#MPU)
  - [MCU](#MCU)
  - [SoC](#SoC)


# <a name="GitTips" >**GitTips**</a>

​	

~~~c
git init
git add 
git commit
git remote add origin http://name:password@gitee.com/zhaochengjie/gitname.git
~~~





## <a name="git gc" >**git_gc**</a>

- ~~~c 
  git gc --prune=now 
  ~~~

​				解决本地缓存过大的问题，清理本地缓存

## <a name="git push" >**git push**</a>

- ~~~c
  git push --force origin master
  ~~~

  强制推送覆盖到远程仓库

  





# <a name="LinuxTips" >**LinuxTips**</a>



# <a name="STM32Tips" >**STM32Tips**</a>



## <a name="内存分配" >**内存分配**</a>

- const修饰的常量，不管在局部还是全局	存放在flash 中，不占用RAM,所以为了节省RAM,把常量的字符串，数据等声明为const是推荐的一种做法
- static修饰的变量，不管是在局部还是在全局	存放于RAM 的.data段，就是已初始化变量区。static不显示初始化默认为初始化为0
- 初始化的全局变量	存放在RAM 的.data段，就是已初始化变量区。static不显示初始化默认为初始化为0
- 未初始化的全局变量	放在RAM的.bss段，也就是没有显示的进行初始化
- HEAP 即堆区	存放于RAM的HEAP段，堆区内存需要程序员用malloc和free进行动态分配和释放，注意不要丢失、改写了申请内存后得到的指针，以免释放不了，造成内存泄漏
- STACK 即栈区	存放于RAM 的STACK段，这部分是程序运行时函数局部变量使用的，使用完自动释放





# <a name="ShellTips" >**ShellTips**</a>

-  指令太长的话 可以使用 “\【Enter】”来进行下一行输出
- “\”表示仅跳脱紧接着的下一个字符，中间不能包含空格

- # ##

  

  - echo ${path#/*:}   一个#代表删除掉最短的一个“/\*:” ,

  - ~~~SHELL
    echo ${path#/*:}
    /usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:
    /root/bin     
    ~~~

  - 

  - echo ${path##/\*:}  两个 ## 表示删除掉最长的那个数据

  - ~~~shell
    echo ${path##/*:}
    /root/bin
    ~~~

  - 



- \# 代表  `从前面开始删除变量的内容` ，如果想要 `从后面向前删除变量内容` 呢：这个时候就得使用百分比 `%`  符号了

  - 我想要从最后面删除从 `:` 到`bin`  为止的字符串 ：

  - ~~~shell
    echo ${path%:*bin}
    ~~~

  - 同理 `%%` 代表的则是最长的符合字符串

  - ~~~shell
    echo ${path%%:*bin}
    ~~~

- 取代功能： 

  - ~~~shell
    echo ${path/sbin/SBIN}
    ~~~

  - 关键词在于两个斜线，两斜线中间的是旧字符串，后面的是新字符串

  - 如果是两条斜线，那莪旧变成所有符合的内容都会被取代

  - ~~~shell
    echo ${path//sbin/SBIN}
    ~~~



- ~~~shell
  ${变量#关键词} ：若变量内容从头开始的数据符合【关键词】，则将符合的最短数据删除
  ${变量##关键词} ：若变量内容从头开始的数据符合【关键词】，则将符合的最长数据删除
  ${变量%关键词} ：若变量内容从尾向前的数据符合【关键词】，则将符合的最短数据删除
  ${变量%%关键词} ：若变量内容从尾向前的数据符合【关键词】，则将符合的最长数据删除
  ${变量/旧字符串/新字符串} ：若变量内容符合【旧字符串】则【第一个旧字符串会被新字符串取代】
  ${变量//旧字符串/新字符串} ：若变量内容符合【旧字符串】则【全部的旧字符串会被新字符串取代】
  ~~~

- 









## <a name="udhcpc" >**udhcpc**</a>

- ~~~c 
  udhcpc -i usb1
  ~~~

​			动态获取ip配置

udhcpd就是终端设备作为DHCP服务器

udhcpc就是终端设备作为DHCP客户端



## <a name="dir" >**dir**</a>

- ls(list)：会显示不同类型的文件的颜色

  dir(directory)：不显示不同文件类型的文件颜色，所有文件都是一种颜色

  但两种指令的作用都是显示当前目录下的文件。

## <a name="yes" >**yes**</a>



- 单个yes输出y
- yes + 字符串。 连续输出字符串。

## <a name="history" >**history**</a>

- 查看使用过的shell指令 甚至曾经在指令列输入过的密码也会保存下来



## <a name="alias" >**alias**</a>

- alias ll='ls -al' 别名设置，将‘ls -al’用“ll”来替换，减少复杂输入。



## <a name="通配符" >**通配符**</a>

- “*”：星号，替代零个，一个或者多个字符
- “？”：问号，替代一个字符



## <a name="type" >**type**</a>

- 透过type 这个指令我们可以知道每个指令是否为bash 的内建指令
- type [-tpa]  name  
- 与which指令有一定的相似之处

## <a name="read " >**read **</a>

- read \-p "Please keyin your name: " \-t 30 named    提示使用者30s内输入自己的大名，将该输入字符串作为名为named的变量内容
- echo $named 则可以显示输入的内容



## <a name="declare/typeset" >**declare/typeset**</a>



- declare [-aixr] variable 
- -a:将variable的变量定义为数组（array）类型
- -i：将variable的变量定义为证书数字（integer）类型
- -x：用法与export一样，就是将后面的variable变成环境变量
- -r：将变量设定为readonly类型，该变量不可被更改内容，也不能unset



- 例子：

- ~~~ sh
   sum=100+300+500 
   echo $sum
   100+300+500
  ~~~

- ~~~shell
  declare -i sum=100+300+500 
   echo $sum
   450
  ~~~

- bash 对于变量有几个基本的定义：

  - 变量类型默认为字符串，若不指定变量类型，则1+2为一个字符串而不是计算式
  - bash 环境中的数值运算，预设最多仅能达到整数形态，所以1/3=0



## <a name="ulimit" >**ulimit**</a>



- ulimit [-SHacdfltu] [配额]
- ulimit -a   列出当前身份的所有限制资料数值
- ulimit -f 10240  限制用户仅能建立10MBytes以下的容量的档案



## <a name="dd" >**dd**</a>



- dd if=/dev/zero of=file count=10 bs=1024 
  - 例如/dev/zero文件代表一个永远输出 0的设备文件，使用它作输入可以得到全为空的文件。因此可用来创建新文件和以覆盖的方式清除旧文件。下面使用dd命令将从zero设备中创建一个10K大小（bs决定每次读写1024字节，count定义读写次数为10次），
    但内容全为0的文件。



# <a name="VimTips" >**VimTips**</a>





~~~mermaid
graph LR
    
A["一般模式</br>游标的移动,搜寻与取代，</br>删除资源，删除整列，</br>复制整列，粘贴整列"] --"i,o,a(插入)R(取代)"-->B["编辑模式</br>以插入或取代来编辑档案内容"]
B --"ESC"-->A
 C["指令列模式</br>读取/存储档案，其他额外功能"] --"ESC"-->A
  A --":，/，?"-->C


~~~



## <a name="编辑" >**编辑**</a>

- 编辑模式：在一般模式中可以迚行删除、复制、贴上等等癿劢作，但是却无法编辑文件内容癿！要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母乊后才会迚入编辑模式。注意了！通常在Linux中，按下这些按键时，在画面癿左下方会出现『INSERT戒REPLACE』癿字样，此时才可以迚行编辑。而如果要回到一般模式时，则必须要按下『Esc』这个按键即可退出编辑模式。
- 在vi 里面，[tab] 这个按钮所得到癿结果不空格符所得到癿结果是丌一样癿，特别强调一下！
- 需要注意癿是，如果你癿档案权限丌对，例如为\-r\--r-\-r\--时，那么可能会无法写入，此时可以使用『强制写入』癿方式吗？可以！使用『:wq!』多加一个惊叹号即可！丌过，需要特别注意呦！那个是在『你癿权限可以改变』癿情况下才能成立癿！
- i、I  ：进入插入模式（insert mode）。i为【从目前光标所在处插入】，I为【在目前所在行的第一个空格符处开始插入】。（常用）
- a、A  ：进入插入模式（insert mode）。a为【从目前光标所在的下一个字符处开始插入】，A为【从光标所在行的最后一个字符处开始插入】。（常用）
- o、O ：进入插入模式（insert mode）。这是英文字母 o 的大小写。 o为【在目前光标所在处的下一行插入新的一行】；O为【在目前光标所在处的上一行插入新的一行】（常用）
- r、R ：进入取代模式（Replace mode）。r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下ESC为止；（常用）

## <a name="移动光标" >**移动光标**</a>

- h 的键位于左边或左箭头键(←)，每次按下就会向左移动;

  l 的键位于右边或或向右箭头键(→)，每次按下就会向右移动;

  j 键看起来很象一支尖端方向朝下的箭头向下箭头键(↓);

  k键每次按下就会向上移动或向上箭头键(↑).

- 如果想要进行多次移动的话，例如向下移动30 行，可以使用"30j" 或"30

  ↓" 的组合按键，亦即加上想要进行的次数(数字)后，按下动作即可！

- ​	H:光标移动到这个屏幕最上方那一行的第一个字符

-  M；光标移动到这个屏幕的中央那一行的第一个字符

-  L：光标移动到这个屏幕的最下方那一行的第一个字符

-  G:移动到这个档案的最后一行

-  nG ：n为数字。移动到这个档案的第n行。例如20G则会移动到这个档案的第20行（可配合:set nu）

- gg : 移动到这个档案的第一行，相当于1G啊！

- n <Enter> : n为数字。光标向下移动n行

- /word 向光标之下寻找一个名称为word的字符串。例如要在档案内搜寻HandsomeZCJ这个字符串，就输入 /HandsomeZCJ 即可

-  ?word 向光标之上寻找一个字符串名称为word的字符串 

-  n ：这个n是英文按键。代表【重复前一个搜寻的动作】。距离来说，如果刚刚我们执行 /HandsomeZCJ   去向下搜寻HandsomeZCJ   这个字符串，则按下n后，会向下继续搜寻下一个名称为HandsomeZCJ   的字符串。如果是执行 ?HandsomeZCJ 的话，那么按下n则会向上继续搜寻名称为HandsomeZCJ   的字符串。   

- N ：这个N是英文按键。与n刚好相反，为【反向】进行前一个搜寻动作。例如/HandsomeZCJ   后，按下N则表示【向上】搜寻HandsomeZCJ   

-  :n1,n2s/word1/word2/g   ： n1 与 n2 为数字。在第 n1 与 n2 行之间寻找word1 这个字符串，并将该字符串取代为word2 ！丼例来说，在100 到

  200 行乊间搜寻vbird 并叏代为VBIRD 则：『:100,200s/vbird/VBIRD/g

  』。(常用)

- :1,$s/word1/word2/g    ：从第一行到最后一行寻找word1字符串，并将该字符串取代为word2
- :1,$s/word1/word2/gc    ： 从第一行到最后一行寻找word1字符串，并将该字符串取代为word2，且在取代前显示提示字符给用户确认（confirm）是否需要取代







~~~mermaid
graph LR
A("Ctrl+f") ----> B("屏幕向下移动一页，相当于【page down按键】")
C("Ctrl+b") ----> D("屏幕向上移动一页，相当于【page up按键】")
E("Ctrl+d") ----> F("屏幕向下移动半页")
G("Ctrl+u") ----> H("屏幕向上移动半页")
I("+") ---->J("光标移动到非空格符的下一列")
K("-") ---->L("光标移动到非空格符的上一列")

~~~

~~~mermaid
graph LR
M("n< space >")---->N("那个n表示『数字』，</br>例如20。按下数字后再按空格键，</br>光标会向右移动这一行的n个字符。</br>例如20<space>则光标</br>会向后面移动20 个字符距离。")
~~~

~~~mermaid
graph LR
A["0或功能键【home】"]---->B("数字0，移动到这一行的最前面字符处")
C(("$或者功能键【End】"))---->D("移动到这一行的最后面字符处")
~~~



## <a name="进入和退出" >**进入和退出**</a>

- 首先确保自己在正常模式（ 按<ESC>键）

然后按键盘上按下”shift+：”，输入“q！”，回车

这种方式的退出编辑器会丢弃您进入编辑器以来所做的改动

输入“wq”则会保存所做的改动。



## <a name="删除" >**删除**</a>

- 输入dd删除该行。
- 输入ndd删除n行，n代表删除以下多少行。
- 在一行字当中，x 为向后删除一个字符（相当于【del】按键）， X 为向前删除一个字符（相当于【backspace】亦既是退格键）
- nx ：n为数字，连续向后删除n个字符。举例来说，我要连续删除10个字符 【10x】
- d1G  ：删除光标所在到第一行的所有数据
- dG   ：删除光标所在到最后一行的所有数据
-  d$  ：删除游标所在处，到该行的最后一个字符
- d0   ： 那个是数字的0，



## <a name="撤销" >**撤销**</a>

- 输入u撤销最后一次执行的命令。
- 输入Ctrl+R可以重做被撤销的命令。

## <a name="定位" >**定位**</a>

- 输入大写 G 可以使得当前光标直接跳转到文件最后一行。
-  输入 gg 可以使得当前光标直接跳转到文件第一行。

- 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底 部，这跟 : 命令是一样的。接着输入 errroor <回车>。那个errroor就是您要查找的字符串。要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字 符串，请输入大写 N 即可。如果您想逆向查找字符串，请使用 ? 代替 / 进行。

## <a name="外部命令" >**外部命令**</a>

- 输入 :! 然后紧接着输入一个外部命令可以执行该外部命令按下我们所熟悉的 : 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。我们以 ls 命令为例。输入 !ls <回车> 。该命令就会列举出您当前目录的 内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起 作用，您可以试试 :!dir 看看。



## <a name="复制" >**复制**</a>



- yy   ：复制光标所在的那一行（常用）
- nyy ：n为数字。复制光标所在的向下n列，例如20yy则是复制20列（常用 ）
- y1G ：复制光标所在列到第一列的所有数据
- yG   : 复制光标所在列到最后一列的所有数据
- y0    ：复制光标所在的那个字符到该行行首的所有数据
- y$  ： 复制光标所在的那个字符到该行行尾的所有数据



## <a name="粘贴" >**粘贴**</a>



- p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第20 行，且已经复制了10 行数据。则按下p 后，那10 

  行数据会贴在原本的20 行之后，亦即由21 行开始贴。但如果是按下P 呢？那么原本的第20 行会被推到变成30 行。(常用)

- J  ：将光标所在列与下一列的 数据 结合成同一列

- c  ：重复删除多个数据，例如向下删除10行，【10cj】

- u  ：复原前一个动作（常用）

- [Ctrl] + r  ：重做上一个动作（常用）

-  .       ：不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！(常用)



## <a name="指令列" >**指令列**</a>



- [:w]   ：将编辑的数据写入硬盘档案中（常用）
- [:w!] ：若文件属性为【只读】时，强制写入该档案。不过，到底能不能写入，还是跟你对该档案的档案权限有关啊！
- [:q] ：离开vi（常用）
- [:q!] ：若曾修改过档案，又不想储存，使用! 为强制离开不储存档案。
- 注意一下啊，那个惊叹号(!) 在vi 当中，常常具有『强制』的意思～
- [:wq] ：储存后离开，若为 [:wq!]则为强制储存后离开（常用）
- [ZZ] ：这是大写的Z，若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开。
- [:w  filename] ：将编辑的数据储存成另一个档案（类似另存新档）
- [:r filename] ：在编辑的数据中，读入另一个档案的数据。亦即将 [filename] 这个档案的内容加到游标所在行后面。
- [:n1,n2 w filename] ：将n1和n2的内容储存成filename这个档案。
- [:!command]  ：暂时离开vi到指令列模式下执行command的显示结果。例如[:! ls /home]即可在vi当中查看 /home 底下以ls输出的档案信息。
- [:set nu] ：显示行号，设定之后，会在每一行的前缀显示该行的行号。
- [:set nonu] ： 与set nu相反，为取消行号

- 区块选择（Visual Block） ：
  - v  ：字符选择，会将光标经过的地方反白选择
  - V ：行选择，会将光标经过的行反白选择
  - [Ctrl] + v   ：区块选择，可以用长方形的方式选择资料
  - y  ： 将反白的地方复制起来
  - d  ：将反白的地方删除掉
- [:n]   ；编辑下一个档案
- [:N] ：编辑上一个档案
- [:files] ：列出目前这个vim的开启的所有档案
-  通过 [vim filename1 filename2 ]指令来使用vim开启两个档案
- [:sp {filename}] ：打开两个窗口， **[:sp]**直接将同一文件打开两个窗口，继续**`[:sp]`**可以连续打开多个窗口，利用**`[ctrl + w + ↑]`**或**`[ctrl + w + k]`**  及**`[ctrl + w + ↓] `**或**`[ctrl + w + j]`**在两个窗口之间移动，这样的话，复制，查阅等等，就简单许多。 （按下ctrl + w  然后松开，再按上下键。）**`[ctrl + w + q]`** ：其实就是 【:q】结束离开。举例来说，如果我想要结束下方的窗口，那么利用**`[ctrl + w + ↓] `**移动到下方窗口后，再按下 【:q】即可离开，也可以按下**`[ctrl + w + q]`**
- 

# <a name="ElectronicsTips" >**ElectronicsTips**</a>



## <a name="晶振" >**晶振**</a>



- 电子线路中的晶体振荡器也分为无源晶振和有源晶振两种类型。无源晶振与有源晶振的英文名称不同，无源晶振为crystal（晶体），而有源晶振则叫做oscillator（振荡器）。无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来，所以“无源晶振”这个说法并不准确；有源晶振有4只引脚，是一个完整的振荡器，其中除了石英晶体外，还有晶体管和阻容元件，因此体积较大。



## <a name="CPU" >**CPU**</a>

- CPU(Central Processing Unit)，是一台计算机的运算核心和控制核心。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。主要功能是解释计算机指令以及处理计算机软件中的数据。计算机的可编程性主要是指对中央处理器的编程。1970年代以前，中央处理器由多个独立单元构成，后来发展出由集成电路制造的中央处理器，这些高度收缩的组件就是所谓的微处理器，其中分出的中央处理器最为复杂的电路可以做成单一微小功能强大的单元，也就是所谓的核心。差不多所有的CPU的运作原理可分为四个阶段：提取(Fetch)、解码(Decode)、执行(Execute)和写回(Writeback)。 CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。



## <a name="MPU" >**MPU**</a>



- MPU (Micro Processor Unit)，叫微处理器，是可编程特殊集成电路。MPU只是一个处理器，需要搭配内存等非常多的其他外设才可以构成一个系统。MCU内部有处理器、内存、Flash及其他模块，仅仅需要搭配少量外设就可以构成一个系统。在上世纪80年代非常流行，那时的微型计算机、游戏机都是使用MPU。比如Motorola公司的68000芯片就是一款主流的微处理器(MPU)。下图是一款Alpha Micro AM-1000系列的微型计算机电路板，电路板右侧中间最大的芯片就是MPU 68000。后来MPU逐渐式微，可以认为MPU发现到现在只剩下了intel、AMD公司x86系列CPU。这类CPU也越来越复杂，称之为“微处理器”似乎不恰当了。在个人电脑领域，可以看到类似下图的主板。主板上插上CPU、内存条、声卡等等就构成了一台计算机。整个主板体积庞大、制造复杂。



## SoC<a name="MCU" >**MCU**</a>



- MCU(Micro Control Unit)，叫微控制器，是指随着大规模集成电路的出现及其发展，把中央处理器、存储器、定时/计数器（timer/counter）、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机，形成芯片级的芯片。与应用在个人电脑中的通用型微处理器相比，它更强调自供应（不用外接硬件）和节约成本。它的最大优点是体积小，可放在仪表内部，但存储量小，输入输出接口简单，功能较低。MCU的发展经历过8位8051单片机、16位AVR单片机、32位STM单片机。MCU内部集成了处理器和各类模块，比如USB控制器、UART控制器、内存、Flash等等。只需要外接少量的器件，就可以搭建一个电子系统。



## <a name="SoC" >**SoC**</a>



- 单片系统或片上系统（英语：System on a Chip，缩写：SoC）是一个将电脑或其他电子系统集成到单一芯片的集成电路。单片系统可以处理数字信号、模拟信号、混合信号甚至更高频率的信号。单片系统常常应用在嵌入式系统中。单片系统的集成规模很大，一般达到几百万门到几千万门。SoC可以基于 MCU或 MPU，并将提供执行某些类型的应用程序所需的一切。例如，对于图像处理，SoC可能具有 MPU、数字信号处理器 (DSP)和/或图形处理单元 (GPU)的组合，用于执行快速算法计算，以及用于驱动显示器和 HDMI或其他音频/视频输入/输出技术。SoC可在单个微型 IC上实现整个芯片系统。
